// MIT License
// Copyright (c) 2021 vasvl123
// https://github.com/vasvl123/onesharp.net

using System;
using System.Drawing;
using System.IO;

namespace onesharp.lib
{

    class ГСЧ

    {
        private readonly Random _random;

        public ГСЧ(int seed = 0)
        {
            if (seed == 0)
                _random = new Random();
            else
                _random = new Random(seed);
        }

        public double Ч()
        {
            double ч = СлучайноеЧисло(0, 1000);
            return ч / 1000;
        }

        public long СлучайноеЧисло(object low = null, object high = null)
        {
            long lo64 = 0, hi64 = UInt32.MaxValue;

            if (low != null)
                lo64 = (int)low;

            if (high != null)
                hi64 = (int)high;

            if (lo64 < 0 || lo64 > 4294967295)
                throw new Exception("Invalid argument value");

            if (hi64 < 0 || hi64 > 4294967295)
                throw new Exception("Invalid argument value");

            if (hi64 < lo64)
                throw new Exception("Invalid argument value");

            // Приводим к рабочему диапазону
            lo64 += Int32.MinValue;
            hi64 += Int32.MinValue;

            int lo = (int)lo64, hi = (int)hi64;

            int v = _random.Next(lo, hi);
            long v64 = v;
            v64 -= Int32.MinValue;

            return v64;
        }

        public static ГСЧ constr(int seed)
        {
            return new ГСЧ(seed);
        }

        public static ГСЧ constr()
        {
            return new ГСЧ();
        }

    }


    public class tracer : Onesharp
    {

        public tracer ЭтотОбъект { get { return this; } }

        public tracer() : base("tracer")
        {
        }

        double пи = 3.14159265359;
        double МАКС_ЧИСЛО = 999999999999999;
        Вектор НулевойВектор = Новый_Вектор(0, 0, 0);
        Вектор ЕдиничныйВектор = Новый_Вектор(1, 1, 1);
        Вектор ЕдиничныйВекторX = Новый_Вектор(1, 0, 0);
        Вектор ЕдиничныйВекторY = Новый_Вектор(0, 1, 0);
        Вектор ЕдиничныйВекторZ = Новый_Вектор(0, 0, 1);

        struct Вектор
        {
            public Вектор(double _x = 0, double _y = 0, double _z = 0)
            {
                x = _x;
                y = _y;
                z = _z;
            }

            public double x;
            public double y;
            public double z;
        }

        static Вектор Новый_Вектор(double x = 0, double y = 0, double z = 0)
        {
            return new Вектор(x, y, z);
        } // Новый_Вектор()

        void Вектор_Печать(Вектор В1)
        {
            Сообщить("(" + В1.x + "," + В1.y + "," + В1.z + ")");
        } // Вектор_Печать()

        static Вектор Вектор_Минус(Вектор В1)
        {
            return new Вектор(- В1.x, - В1.y, - В1.z);
        } // Вектор_Минус()

        static Вектор Вектор_Сумма(Вектор В1, Вектор В2)
        {
            return new Вектор(В1.x + В2.x, В1.y + В2.y, В1.z + В2.z);
        } // Вектор_Сумма()

        static Вектор Вектор_Разность(Вектор В1, Вектор В2)
        {
            return new Вектор(В1.x - В2.x, В1.y - В2.y, В1.z - В2.z);
        } // Вектор_Разность()

        static Вектор Вектор_Умножить(Вектор В1, double ч)
        {
            return new Вектор(В1.x * ч, В1.y * ч, В1.z * ч);
        } // Вектор_Умножить()

        static double Вектор_СкалярноеПр(Вектор В1, Вектор В2)
        {
            return В1.x * В2.x + В1.y * В2.y + В1.z * В2.z;
        } // Вектор_СкалярноеПр()

        static double Вектор_Норма(Вектор В1)
        {
            return Sqrt(В1.x * В1.x + В1.y * В1.y + В1.z * В1.z);
        } // Вектор_Норма()

        static double Вектор_КвНормы(Вектор В1)
        {
            return В1.x * В1.x + В1.y * В1.y + В1.z * В1.z;
        } // Вектор_КвНормы()

        static Вектор Вектор_Нормализация(Вектор В1)
        {
            var норма = Вектор_Норма(В1);
            В1.x = В1.x / норма;
            В1.y = В1.y / норма;
            В1.z = В1.z / норма;
            return В1;
        } // Вектор_Нормализация()

        static double Abs(double ч)
        {
            return (ч < 0 ? - ч : ч);
        } // Abs()

        static int Норм_Цвет(double цв)
        {
            return Цел(255 * Макс(0, Мин(1, цв)));
        } // Норм_Цвет()

        struct Кадр
        {
            public Кадр(Вектор _ЦветФона, Массив _Сферы, Массив _Освещение, int _Ширина, int _Высота, double _УголЗрения, int _ГЛУБИНА_РЕКУРСИИ)
            {
                ЦветФона = _ЦветФона;
                Сферы = _Сферы;
                Освещение = _Освещение;
                Ширина = _Ширина;
                Высота = _Высота;
                УголЗрения = _УголЗрения;
                ГЛУБИНА_РЕКУРСИИ = _ГЛУБИНА_РЕКУРСИИ;
            }

            public Вектор ЦветФона;
            public Массив Сферы;
            public Массив Освещение;
            public int Ширина;
            public int Высота;
            public double УголЗрения;
            public int ГЛУБИНА_РЕКУРСИИ;
        }

        struct Сфера
        {
            public Сфера(Вектор _ц, double _р, Материал _мат)
            {
                Центр = _ц;
                Радиус = _р;
                Материал = _мат;
            }

            public Вектор Центр;
            public double Радиус;
            public Материал Материал;
        }

        static Сфера Новая_Сфера(Вектор ц, double р, Материал мат)
        {
            return new Сфера(ц, р, мат);
        } // Новая_Сфера()

        struct Свет
        {
            public Свет(Вектор _п, double _я)
            {
                Поз = _п;
                Ярк = _я;
            }

            public Вектор Поз;
            public double Ярк;
        }

        static Свет Новый_Свет(Вектор поз, double ярк)
        {
            return new Свет(поз, ярк);
        } // Новый_Свет()

        struct Материал
        {
            public Материал(Вектор Цв, double Ал0, double Ал1, double Ал2, double Ал3, double Отр, double Пр)
            {
                Цвет = Цв;
                Альб0 = Ал0;
                Альб1 = Ал1;
                Альб2 = Ал2;
                Альб3 = Ал3;
                ЭкспОтраж = Отр;
                КПрелом = Пр;
            }

            public Вектор Цвет;
            public double Альб0;
            public double Альб1;
            public double Альб2;
            public double Альб3;
            public double ЭкспОтраж;
            public double КПрелом;
        }

        static Материал Новый_Материал(Вектор Цв, double Ал0, double Ал1, double Ал2, double Ал3, double Отр, double Пр)
        {
            return new Материал(Цв, Ал0, Ал1, Ал2, Ал3, Отр, Пр);
        } // Новый_Материал()

        static bool Сфера_Пересечение(Сфера Сф, Вектор Исх, Вектор Напр, ref double Расст)
        {
            var КЦентру = Вектор_Разность(Сф.Центр, Исх);
            var пр = Вектор_СкалярноеПр(КЦентру, Напр);
            var д2 = Вектор_КвНормы(КЦентру) - пр * пр;
            var р2 = Сф.Радиус * Сф.Радиус;
            if (д2 > р2)
            {
                return Ложь;
            }
            var р = Sqrt(р2 - д2);
            Расст = пр - р;
            if (Расст < 0)
            {
                Расст = пр + р;
                if (Расст < 0)
                {
                    return Ложь;
                }
            }
            return Истина;
        } // Сфера_Пересечение()

        bool НайтиПересечения(Кадр Кадр, Вектор Исх, Вектор Напр, ref object _Точка, ref object Нормаль, ref object Материал)
        {
            double Расст = 0;
            var МинРасст = МАКС_ЧИСЛО;
            foreach (Сфера Сф in Кадр.Сферы)
            {
                if ((Сфера_Пересечение(Сф, Исх, Напр, ref Расст)) && (Расст < МинРасст))
                {
                    МинРасст = Расст;
                    _Точка = Вектор_Сумма(Исх, Вектор_Умножить(Напр, Расст));
                    Вектор Точка = (Вектор)_Точка;
                    Нормаль = Вектор_Нормализация(Вектор_Разность(Точка, Сф.Центр));
                    Материал = Сф.Материал;
                }
            }

            return МинРасст < 1000;
        } // НайтиПересечения()

        Вектор Отражение(Вектор Луч, Вектор Норм)
        {
            return Вектор_Разность(Луч, Вектор_Умножить(Норм, 2 * Вектор_СкалярноеПр(Луч, Норм)));
        } // Отражение()

        Вектор Преломление(Вектор Луч, Вектор Норм, double КоэфПр)
        {
            double эта;
            Вектор Н;

            if (КоэфПр == 1)
            {
                return Луч;
            }
            var CosI = - Макс(- 1, Мин(1, Вектор_СкалярноеПр(Луч, Норм)));
            if (CosI >= 0)
            {
                эта = 1 / КоэфПр;
                Н = Норм;
            }
            else
            {
                CosI = - CosI;
                эта = КоэфПр;
                Н = Вектор_Минус(Норм);
            }
            double К = 1 - эта * эта * (1 - CosI * CosI);
            if (К < 0)
            {
                return ЕдиничныйВекторX;
            }
            return Вектор_Сумма(Вектор_Умножить(Луч, эта), Вектор_Умножить(Н, эта * CosI - Sqrt(К)));
        } // Преломление()

        Вектор ТрассироватьЛуч(Кадр Кадр, Вектор Исх, Вектор Напр, int Глубина = 0)
        {


            object _Точка = null;
            object _Нормаль = null;
            object _Материал = null;
            if (Глубина > Кадр.ГЛУБИНА_РЕКУРСИИ || !(НайтиПересечения(Кадр, Исх, Напр, ref _Точка, ref _Нормаль, ref _Материал)))
            {
                return Кадр.ЦветФона;
            }
            Вектор Точка = (Вектор)_Точка;
            Вектор Нормаль = (Вектор)_Нормаль;
            Материал Материал = (Материал)_Материал;
            var СдвигПоНормали = Вектор_Умножить(Нормаль, 0.001);
            var ОтражНапр = Отражение(Напр, Нормаль);
            // нормализовано
            var ОтражИсх = (Вектор_СкалярноеПр(ОтражНапр, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
            var ОтражЦвет = ТрассироватьЛуч(Кадр, ОтражИсх, ОтражНапр, Глубина + 1);
            var ПреломНапр = Вектор_Нормализация(Преломление(Напр, Нормаль, Материал.КПрелом));
            var ПреломИсх = (Вектор_СкалярноеПр(ПреломНапр, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
            var ПреломЦвет = ТрассироватьЛуч(Кадр, ПреломИсх, ПреломНапр, Глубина + 1);
            double Яркость = 0;
            double Блик = 0;
            foreach (Свет Свет in Кадр.Освещение)
            {
                var НапрКСвету = Вектор_Нормализация(Вектор_Разность(Свет.Поз, Точка));
                var РасстДоСвета = Вектор_КвНормы(Вектор_Разность(Свет.Поз, Точка));
                var ТеньИсх = (Вектор_СкалярноеПр(НапрКСвету, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
                object _ТеньТочка = null;
                object _ТеньНормаль = null;
                object _ВремМатериал = null;
                if (НайтиПересечения(Кадр, ТеньИсх, НапрКСвету, ref _ТеньТочка, ref _ТеньНормаль, ref _ВремМатериал) && Вектор_КвНормы(Вектор_Разность((Вектор)_ТеньТочка, ТеньИсх)) < РасстДоСвета)
                {
                    continue;
                }
                Яркость = Яркость + Свет.Ярк * Макс(0, Вектор_СкалярноеПр(НапрКСвету, Нормаль));
                //powf(std::max(0.f, -reflect(-light_dir, N)*dir), material.specular_exponent)*lights[i].intensity;
                Блик = Блик + Свет.Ярк * Pow(Макс(0, Вектор_СкалярноеПр(Отражение(НапрКСвету, Нормаль), Напр)), Материал.ЭкспОтраж);
            }
            return Вектор_Сумма(Вектор_Сумма(Вектор_Сумма(Вектор_Умножить(Материал.Цвет, Яркость * Материал.Альб0), Вектор_Умножить(ЕдиничныйВектор, Блик * Материал.Альб1)), Вектор_Умножить(ОтражЦвет, Материал.Альб2)), Вектор_Умножить(ПреломЦвет, Материал.Альб3));
        } // ТрассироватьЛуч()

        string Рендер(Кадр Кадр, int Высота, int Ширина, int _верт, int _гор, int _выс, int _шир, int _мшб)
        {
            Bitmap кар = new Bitmap(_шир,_выс);
            
            var рез = "";
            var Камера = Новый_Вектор(0, 0, 0);
            var Напр_Z = - Высота / (2 * Tan(Кадр.УголЗрения / 2));
            for (int верт = _верт; верт <= _верт + _выс - 1; верт++)
            {
                var Напр_Y = - (верт + 0.5) + Высота / 2;
                for (int гор = _гор; гор <= _гор + _шир - 1; гор++)
                {
                    var Напр_X = (гор + 0.5) - Ширина / 2;
                    var Направление = Вектор_Нормализация(new Вектор(Напр_X, Напр_Y, Напр_Z));
                    var цв = ТрассироватьЛуч(Кадр, Камера, Направление);
                    кар.SetPixel(гор - _гор, верт - _верт, Color.FromArgb(255, Норм_Цвет(цв.x), Норм_Цвет(цв.y), Норм_Цвет(цв.z)));
                }
            }
            
            using (var ms = new MemoryStream())
            {
                кар.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
                рез = "<img src='data:image/png;base64," + Convert.ToBase64String(ms.ToArray()) + "' style='width:" + _шир*_мшб + "px;height:" + _выс*_мшб + "px;'>";
            }
            
            return рез;
            
        } // Рендер()

        //void СохранитьКадр(string ИмяФайла)
        //{
        //    var файл = Новый.ТекстовыйДокумент();
        //    файл.ДобавитьСтроку("P3");
        //    файл.ДобавитьСтроку("" + Ширина + " " + Высота);
        //    файл.ДобавитьСтроку("255");
        //    for (int п = 0; п <= Высота * Ширина - 1; п++)
        //    {
        //        var Пиксел = (Вектор)Кадр[п];
        //        var МаксИнт = Макс(Пиксел.x, Макс(Пиксел.y, Пиксел.z));
        //        if (МаксИнт > 1)
        //        {
        //            МаксИнт = 1 / МаксИнт;
        //            Пиксел.x = Пиксел.x * МаксИнт;
        //            Пиксел.y = Пиксел.y * МаксИнт;
        //            Пиксел.z = Пиксел.z * МаксИнт;
        //        }
        //        файл.ДобавитьСтроку("" + Норм_Цвет(Пиксел.x) + " " + Норм_Цвет(Пиксел.y) + " " + Норм_Цвет(Пиксел.z));
        //    }
        //    файл.Записать(ИмяФайла, "ANSI");
        //} // СохранитьКадр()


        public object УзелСвойство(Структура Узел, string Свойство)
        {
            object УзелСвойство = null;
            if (!(Узел == Неопределено))
            {
                Узел.Свойство(Свойство, out УзелСвойство);
            }
            return УзелСвойство;
        } // УзелСвойство(Узел)

        public Узел ИмяЗначение(string Имя = "", object _Значение = null)
        {
            var Значение = (_Значение is null) ? "" : _Значение;
            return Узел.Новый("Имя, Значение", Имя, Значение);
        }

        public string Страница_Свойства(pagedata Данные, Узел оУзел)
        {
            object Свойства = null;
            var шСвойства = "";

            if (!(оУзел.Свойство("Свойства", out Свойства)))
            { // новый объект
                Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""), Истина);
            }

            шСвойства = @"
            |*Новая: Да
            |*Имя
            |*Ид
            |*События";

            Данные.СоздатьСвойства(Свойства as Узел, шСвойства, "Только");
            оУзел.Вставить("Свойства", Свойства);

            return null;
        }

        Узел ЗаполнитьОкно(pagedata Данные, Узел п, Массив Ид)
        {
                        
            var п1 = Данные.НовыйДочерний(п, ИмяЗначение("div"), Истина, Истина);

            for (int верт = 0; верт < 2; верт++)
            {
                var п2 = Данные.НовыйДочерний(п1, ИмяЗначение("div"), Истина, Истина);
                Данные.НовыйАтрибут(п2, ИмяЗначение("style", "display:flex; flex-wrap: wrap"), Истина);

                for (int гор = 0; гор < 2; гор++)
                {

                    var вп = Данные.НовыйДочерний(п2, ИмяЗначение("О", "tracer.Кадр"), Истина, Истина);
                    var свп = Данные.ОбработатьОбъект(вп, Истина) as Узел;

                    var м = Новый.Массив(Ид.Arr);

                    var ИД = Цел(Данные.Процесс.ПолучитьИД());
                    м.Добавить(ИД);
                    свп.д.с.Ид.Значение = м;
                    свп.д.с.Имя.Значение = "" + ИД;
                    свп.д.с.Ширина.Значение = 64;
                    свп.д.с.Высота.Значение = 64;
                    свп.д.с.Масштаб.Значение = 2;

                    Данные.ОбъектыОбновитьДобавить(вп);
                }

            }

            return п1;

        }

        public void Страница_Модель(pagedata Данные, Узел Свойства, Соответствие Изменения)
        {
            var оУзел = Свойства.Родитель;
                    
            var Ид = Свойства.д.с.Ид.Значение as Массив;
            if (!ЗначениеЗаполнено(Ид))
            {
                Ид = Новый.Массив();
            }

            if (!(УзелСвойство(оУзел, "Обновить") as bool? == Ложь))
            {

                if (Свойства.д.с.Новая.Значение == "Да")
                {

                    var п = Свойства;

                    п = Данные.НовыйСоседний(п, ИмяЗначение("div"), Истина);
                    Данные.НовыйАтрибут(п, ИмяЗначение("style", "display:flex; flex-wrap: wrap"), Истина);

                    if (Ид.Количество() != 0)
                    {
                        var п1 = Данные.НовыйДочерний(п, ИмяЗначение("div"), Истина, Истина);

                        var вп = Данные.НовыйДочерний(п1, ИмяЗначение("О", "tracer.Кадр"), Истина, Истина);
                        var свп = Данные.ОбработатьОбъект(вп, Истина) as Узел;

                        if (Лев(Свойства.д.с.Имя.Значение, 1) == "b")
                        {
                            свп.д.с.Имя.Значение = Свойства.д.с.Имя.Значение;
                            свп.д.с.Ид.Значение = Ид;
                            свп.д.с.Ширина.Значение = 320;
                            свп.д.с.Высота.Значение = 320;
                            свп.д.с.Масштаб.Значение = 1;

                        }
                        else
                        {
                            Данные.НовыйАтрибут(п1, ИмяЗначение("style", "padding: 5px"), Истина);

                            свп.д.с.Имя.Значение = "b" + Свойства.д.с.Имя.Значение;
                            свп.д.с.Ид.Значение = Ид;
                            свп.д.с.Ширина.Значение = 128;
                            свп.д.с.Высота.Значение = 128;
                            свп.д.с.Масштаб.Значение = 2;
                            
                        }
                        Данные.ОбъектыОбновитьДобавить(вп);
                    }
                    else
                    {
                        var к = 5;
    
                        for (int н = 0; н < к; н++) 
                        {
                            ЗаполнитьОкно(Данные, п, Ид);
                        }
                    }

                    if (Лев(Свойства.д.с.Имя.Значение, 1) == "b")
                    {
                    }
                    else
                    {
                        var ш = @"
                        |button	class=btn btn-outline-light btn-sm	style=margin:10px; opacity:0.7;	onclick=addcmd(this,event); return false	role=add
                        |	H1: +	style=width:236px";

                        Данные.СоздатьСвойства(п, ш, Истина, Истина);
                    }
                    
                    Свойства.д.с.Новая.Значение = "Нет";
    
                }

            }
            
            // обработать события
            if (Изменения.Получить(Свойства.д.с.События) as bool? == Истина)
            {
                var дУзел = Свойства.д.с.События.Дочерний as Узел;
                if (!(дУзел is null))
                {
                    var мСобытие = Стр.Разделить(дУзел.Значение as string, Символы.Таб);
                    var тСобытие = мСобытие[0];
                    if (тСобытие == "ПриНажатии")
                    {
                        var сУзел = Данные.ПолучитьУзел(мСобытие[1]);

                        var ЗначениеКнопка = УзелСвойство(дУзел, "Параметры") as string;
                        if (!(ЗначениеКнопка is null))
                        {
                            if (ЗначениеКнопка == "add")
                            {
                                var п = ЗаполнитьОкно(Данные, сУзел.Родитель, Ид);
                                п.Старший = сУзел.Старший;
                                п.Старший.Соседний = п;
                                п.Соседний = сУзел;
                                сУзел.Старший = п;
                                сУзел.Соседний = null;
                                
                                Данные.ОбъектыОбновитьДобавить(сУзел.Родитель);
                            }

                        }
                    }
                    else
                    { // изменение полей
                    }
        
                    Данные.УдалитьУзел(дУзел);
                    //Изменения.Вставить(Свойства.д.События, Истина);
                    //оУзел.Вставить("Обновить", Истина);

                }

            }
            
        }


        public string Пиксель_Свойства(pagedata Данные, Узел оУзел)
        {
            object Свойства = null;
            var шСвойства = "";

            if (!(оУзел.Свойство("Свойства", out Свойства)))
            { // новый объект
                Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""), Истина);
            }

            шСвойства = @"
            |*События
            |*Кадр
            |*Мшб
            |*Гор
            |*Вер
            |*Шир
            |*Выс
            |*Дальше: Да
            |*Вид";

            Данные.СоздатьСвойства(Свойства as Узел, шСвойства, "Только");
            оУзел.Вставить("Свойства", Свойства);

            return null;
        }

        public void Пиксель_Модель(pagedata Данные, Узел Свойства, Соответствие Изменения)
        {
            var оУзел = Свойства.Родитель;

            if (!(УзелСвойство(оУзел, "Обновить") as bool? == Ложь))
            {
                Кадр Кадр = Свойства.д.с.Кадр.Значение;

                int _мшб = Свойства.д.с.Мшб.Значение;

                int _шир = Свойства.д.с.Шир.Значение;
                int _выс = Свойства.д.с.Выс.Значение;

                int _верт = Свойства.д.с.Вер.Значение;
                int _гор = Свойства.д.с.Гор.Значение;

                string Дальше = Свойства.д.с.Дальше.Значение;

                if (Дальше == "Показать")
                {
                    Данные.УдалитьУзел((Узел)Свойства.д.с.Вид);
                    Дальше = "";
                }
                else if (Дальше != "")
                {
                    if (_шир > 32 && _шир%2 == 0 && _выс%2 == 0)
                    {
                        var Камера = Новый_Вектор(0, 0, 0);
                        var Напр_Z = -Кадр.Высота / (2 * Tan(Кадр.УголЗрения / 2));
                        var Напр_Y = -(_верт + 0.5) + Кадр.Высота / 2;
                        var Напр_X = (_гор + 0.5) - Кадр.Ширина / 2;
                        var Направление = Вектор_Нормализация(new Вектор(Напр_X, Напр_Y, Напр_Z));
                        var цв = ТрассироватьЛуч(Кадр, Камера, Направление);
                        var цвзн = "rgb(" + Норм_Цвет(цв.x) + ", " + Норм_Цвет(цв.y) + ", " + Норм_Цвет(цв.z) + ")";
                        Свойства.д.с.Вид.Значение = "<div style='width:" + _шир*_мшб + "px; height:" + _выс*_мшб + "px; background-color: " + цвзн + "'></div>";
                    }
                    else
                    {
                        Свойства.д.с.Вид.Значение = Рендер(Кадр, Кадр.Высота, Кадр.Ширина, _верт, _гор, _выс, _шир, _мшб);
                        Дальше = "";
                    }

                    // разделить пиксель
                    if (Дальше == "Да")
                    {
                        var п = Свойства;

                        for (int верт = 0; верт < 2; верт++)
                        {
                            п = Данные.НовыйДочерний(оУзел, ИмяЗначение("div"), Истина, Истина);
                            Данные.НовыйАтрибут(п, ИмяЗначение("style", "display:flex"), Истина);

                            for (int гор = 0; гор < 2; гор++)
                            {

                                var вп = Данные.НовыйДочерний(п, ИмяЗначение("О", "tracer.Пиксель"), Истина, Истина);
                                var свп = Данные.ОбработатьОбъект(вп, Истина) as Узел;
                                свп.д.с.Гор.Значение = _гор + гор * (_шир / 2);
                                свп.д.с.Вер.Значение = _верт + верт * (_выс / 2);
                                свп.д.с.Шир.Значение = _шир / 2;
                                свп.д.с.Выс.Значение = _выс / 2;
                                свп.д.с.Мшб.Значение = _мшб;
                                свп.д.с.Кадр.Значение = Кадр;

                                Данные.ОбъектыОбновитьДобавить(вп);
                            }

                        }

                        Данные.ОбъектыОбновитьДобавить(оУзел);
                        Дальше = "Показать";

                    }
                    else
                    {
                        Дальше = "";
                    }

                }

                Свойства.д.с.Дальше.Значение = Дальше;

            }
        }


        public string Кадр_Свойства(pagedata Данные, Узел оУзел)
        {
            object Свойства = null;
            var шСвойства = "";

            if (!(оУзел.Свойство("Свойства", out Свойства)))
            { // новый объект
                Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""), Истина);
            }

            шСвойства = @"
            |*Новый: Да
            |*События
            |*Имя
            |*Ширина
            |*Высота
            |*Масштаб
            |*Ид
            |*Вид
            |	div	class=frame	А=ПриНажатии	role=sel
            |		П: Содержимое";
            Данные.СоздатьСвойства(Свойства as Узел, шСвойства, "Только");
            оУзел.Вставить("Свойства", Свойства);

            return null;
        }


        public void Кадр_Модель(pagedata Данные, Узел Свойства, Соответствие Изменения)
        {
            var оУзел = Свойства.Родитель;

            // обработать события
            if (Изменения.Получить(Свойства.д.с.События) as bool? == Истина)
            {
                var дУзел = Свойства.д.с.События.Дочерний as Узел;
                if (!(дУзел is null))
                {
                    var мСобытие = Стр.Разделить(дУзел.Значение as string, Символы.Таб);
                    var тСобытие = мСобытие[0];
                    if (тСобытие == "ПриНажатии")
                    {
                        var сУзел = Данные.ПолучитьУзел(мСобытие[1]);

                        var ЗначениеКнопка = УзелСвойство(дУзел, "Параметры") as string;
                        if (!(ЗначениеКнопка is null))
                        {
                            if (ЗначениеКнопка == "sel")
                            {
                                var м = Свойства.д.с.Ид.Значение as Массив;
                                var Параметры = Новый.Структура("Данные, Свойства, data, templ, cmd", Данные, Свойства, "" + Свойства.д.с.Имя.Значение, "tracer", "newtab");
                                Данные.Процесс.НоваяЗадача(Параметры, "Служебный");
                            }
                        }
                    }
                    else if (тСобытие == "НоваяВкладка")
                    { 
                        var _Данные = УзелСвойство(дУзел, "Параметры") as pagedata;
                        var _оУзел = _Данные.ПолучитьУзел("13");
                        _оУзел.Значение = _Данные.ИмяДанных;
                        _оУзел = _Данные.ПолучитьУзел("20");
                        var _Свойства = _Данные.ОбработатьОбъект(_оУзел, Истина) as Узел;;
                        var м = Новый.Массив(((Массив)Свойства.д.с.Ид.Значение).Arr);
                        if (!ЗначениеЗаполнено(_Свойства.д.с.Ид.Значение)) 
                        {
                            _Свойства.д.с.Имя.Значение = Свойства.д.с.Имя.Значение;
                            _Свойства.д.с.Ид.Значение = м;
                        }
                        else // уже открывали
                        {
                            _Данные.ОбъектыОбновитьДобавить(_оУзел);
                        }
                    }
                    else
                    { // изменение полей
                    }
        
                    Данные.УдалитьУзел(дУзел);
                    //Изменения.Вставить(Свойства.д.События, Истина);
                    //оУзел.Вставить("Обновить", Истина);

                }

            }

            if (!(УзелСвойство(оУзел, "Обновить") as bool? == Ложь))
            {

                if (Свойства.д.с.Новый.Значение == "Да")
                {
                    var Ид = Свойства.д.с.Ид.Значение as Массив;

                    var г = new ГСЧ((int)Ид[0]);

                    var ГЛУБИНА_РЕКУРСИИ = 1;

                    if (Лев(Свойства.д.с.Имя.Значение, 1) == "b")
                        ГЛУБИНА_РЕКУРСИИ = 3;

                    var Ширина = (int)Свойства.д.с.Ширина.Значение;
                    var Высота = (int)Свойства.д.с.Высота.Значение;
                    var УголЗрения = пи / 3;
                    var ЦветФона = Новый_Вектор(г.Ч(), г.Ч(), г.Ч());
                    var Сферы = Новый.Массив();
                    while (г.Ч() > 0.1)
                    {
                        var Серый = Новый_Материал(Новый_Вектор(г.Ч(), г.Ч(), г.Ч()), г.Ч(), г.Ч() * 15, г.Ч(), г.Ч(), г.СлучайноеЧисло(1, 2000), г.Ч() * 3);
                        Сферы.Добавить(Новая_Сфера(Новый_Вектор(г.Ч() * 30 - 15, г.Ч() * 30 - 15, г.Ч() * 30 - 15), г.Ч() * 10, Серый));
                    }
                    var Освещение = Новый.Массив();
                    while (г.Ч() > 0.3)
                    {
                        Освещение.Добавить(Новый_Свет(Новый_Вектор(г.Ч() * 30 - 15, г.Ч() * 30 - 15, г.Ч() * 30 - 15), г.Ч() * 3));
                    }

                    for (var н = 1; н < Ид.Количество(); н++)
                    {
                        г = new ГСЧ((int)Ид[н]);
                        
                        if (г.Ч() > 0.8) УголЗрения *= 2*г.Ч();

                        if (г.Ч() > 0.8) ЦветФона.x *= 2*г.Ч();
                        if (г.Ч() > 0.8) ЦветФона.y *= 2*г.Ч();
                        if (г.Ч() > 0.8) ЦветФона.z *= 2*г.Ч();
                        
                        for (var n = 0; n < Сферы.Количество(); n++) 
                        {
                            var сф = (Сфера)Сферы[n];

                            if (г.Ч() > 0.8) сф.Центр.x *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Центр.y *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Центр.z *= 2*г.Ч();
                            
                            if (г.Ч() > 0.8) сф.Радиус *= 2*г.Ч();
                              
                            if (г.Ч() > 0.8) сф.Материал.Альб0 *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.Альб1 *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.Альб2 *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.Альб3 *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.КПрелом *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.ЭкспОтраж *= 2*г.Ч();
                            
                            if (г.Ч() > 0.8) сф.Материал.Цвет.x *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.Цвет.y *= 2*г.Ч();
                            if (г.Ч() > 0.8) сф.Материал.Цвет.z *= 2*г.Ч();

                            Сферы[n] = сф;
                        }

                        for (var n = 0; n < Освещение.Количество(); n++)
                        {
                            var св = (Свет)Освещение[n];
                            
                            if (г.Ч() > 0.8) св.Поз.x *= 2*г.Ч();
                            if (г.Ч() > 0.8) св.Поз.y *= 2*г.Ч();
                            if (г.Ч() > 0.8) св.Поз.z *= 2*г.Ч();  
                                                      
                            if (г.Ч() > 0.8) св.Ярк *= 2*г.Ч();

                            Освещение[n] = св;
                        }

                    }

                    var Кадр = new Кадр(ЦветФона, Сферы, Освещение, Ширина, Высота, УголЗрения, ГЛУБИНА_РЕКУРСИИ);

                    var вп = Данные.НовыйСоседний(Свойства, ИмяЗначение("О", "tracer.Пиксель"), Истина);
                    var свп = Данные.ОбработатьОбъект(вп, Истина) as Узел;
                    свп.д.с.Гор.Значение = 0;
                    свп.д.с.Вер.Значение = 0;
                    свп.д.с.Шир.Значение = Ширина;
                    свп.д.с.Выс.Значение = Высота;
                    свп.д.с.Мшб.Значение = (int)Свойства.д.с.Масштаб.Значение;

                    свп.д.с.Кадр.Значение = Кадр;
                }

                Свойства.д.с.Новый.Значение = "Нет";
            }

        }

    }
}
